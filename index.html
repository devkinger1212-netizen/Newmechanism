<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable Matching with Leader / Follower Roles</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            max-width: 800px;
            line-height: 1.6;
            color: #333;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-top: 15px;
            font-weight: 500;
        }
        input[type="number"], textarea, input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box; 
        }
        textarea {
            height: 150px;
            resize: vertical;
        }
        button {
            margin-top: 20px;
            width: 100%;
            padding: 10px;
            background-color: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #ddd;
        }
        h2 {
            margin-top: 30px;
            font-size: 20px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #output {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            min-height: 50px;
        }
        .placeholder-text {
            color: #888;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <h1>Stable Matching with Leader / Follower Roles</h1>

    <label for="numAgents">Number of agents:</label>
    <input type="number" id="numAgents" placeholder="e.g. 6">

    <label for="preferences">Preferences (one line per agent):</label>
    <div class="placeholder-text">Example for 6 agents:<br>2 3 4 5 6<br>3 4 1 5 6<br>... (Agent 1 on line 1, Agent N on line N)</div>
    <textarea id="preferences" placeholder="Enter preferences here..."></textarea>

    <label for="roles">Role preferences (L or F, space separated or one per line):</label>
    <div class="placeholder-text">Example: L L L L L L</div>
    <input type="text" id="roles" placeholder="L L L F L F">

    <button onclick="runMechanism()">Run Mechanism</button>

    <h2>Output</h2>
    <div id="output"></div>

    <script>
        // --- 1. Deferred Acceptance Algorithm ---
        function deferredAcceptance(proposers, receivers, prefP, prefR) {
            let free = [...proposers];
            let proposals = {};
            proposers.forEach(p => proposals[p] = []);
            let matchR = {}; // Receiver -> Proposer
            let matchP = {}; // Proposer -> Receiver

            while (free.length > 0) {
                let p = free.shift();
                
                // If p has no prefs or empty prefs
                if (!prefP[p] || prefP[p].length === 0) continue;

                for (let r of prefP[p]) {
                    // Do not propose twice
                    if (proposals[p].includes(r)) continue;
                    
                    proposals[p].push(r);

                    if (!matchR.hasOwnProperty(r)) {
                        // r is free
                        matchR[r] = p;
                        matchP[p] = r;
                        break;
                    } else {
                        // r is matched to cur
                        let cur = matchR[r];
                        let rPrefs = prefR[r] || [];
                        
                        // Check if p and cur are in r's list
                        let idxP = rPrefs.indexOf(p);
                        let idxCur = rPrefs.indexOf(cur);
                        
                        if (idxP !== -1 && idxCur !== -1) {
                            if (idxP < idxCur) {
                                // r upgrades to p
                                matchR[r] = p;
                                matchP[p] = r;
                                delete matchP[cur];
                                free.push(cur);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Merge results
            let finalMatch = {...matchP};
            for (let r in matchR) {
                finalMatch[r] = parseInt(matchR[r]); // Ensure ID is int
            }
            return finalMatch;
        }

        // --- 2. Borda Count Helper ---
        function getBordaScores(n, prefs) {
            let scores = {};
            for (let i = 1; i <= n; i++) scores[i] = 0;

            for (let i = 1; i <= n; i++) {
                let pList = prefs[i] || [];
                let maxScore = n - 1;
                pList.forEach((candidate, rank) => {
                    let points = Math.max(0, maxScore - rank);
                    if (scores.hasOwnProperty(candidate)) {
                        scores[candidate] += points;
                    }
                });
            }
            return scores;
        }

        // --- 3. Utility & Stability ---
        function getUtility(i, role, j, rolePref, g) {
            let target = rolePref[i] || 'L';
            let rolePayoff = (target === role) ? 10 : 5;
            let matchPayoff = 0;
            if (j !== null && g[i] && g[i].hasOwnProperty(j)) {
                matchPayoff = g[i][j];
            }
            return rolePayoff + matchPayoff;
        }

        function checkStability(match, L, F, rolePref, g) {
            let agents = Object.keys(g).map(Number);
            let blockingPairs = [];
            let isStable = true;

            let currentUtilities = {};
            agents.forEach(i => {
                let ri = L.has(i) ? 'L' : 'F';
                let partner = match.hasOwnProperty(i) ? match[i] : null;
                currentUtilities[i] = getUtility(i, ri, partner, rolePref, g);
            });

            for (let i of agents) {
                for (let j of agents) {
                    if (i >= j) continue;

                    let ri = L.has(i) ? 'L' : 'F';
                    let rj = L.has(j) ? 'L' : 'F';

                    let u_i_with_j = getUtility(i, ri, j, rolePref, g);
                    let u_j_with_i = getUtility(j, rj, i, rolePref, g);

                    let u_i_current = currentUtilities[i];
                    let u_j_current = currentUtilities[j];

                    if (u_i_with_j > u_i_current && u_j_with_i > u_j_current) {
                        isStable = false;
                        blockingPairs.push(`(${i}, ${j})`);
                    }
                }
            }
            return { isStable, blockingPairs };
        }

        // --- 4. Main Mechanism Logic ---
        function runLogic(n, prefs, rolePref) {
            let log = [];
            
            // Build g(i,j)
            let g = {};
            for (let i = 1; i <= n; i++) {
                g[i] = {};
                let pList = prefs[i] || [];
                pList.forEach((cand, rank) => {
                    g[i][cand] = 1 - 0.2 * rank;
                });
            }

            // Step 1: Global Borda
            let globalBorda = getBordaScores(n, prefs);
            log.push(`> Global Borda Scores: ${JSON.stringify(globalBorda)}`);

            // Step 2: Fix Strict Pairs
            let fixedRoles = {};
            let potentialPairs = [];

            for (let i = 1; i <= n; i++) {
                let pListI = prefs[i] || [];
                pListI.forEach((partner, rankI) => {
                    if (partner > i) {
                        let pListJ = prefs[partner] || [];
                        let rankJ = pListJ.indexOf(i);
                        if (rankJ !== -1) {
                            let maxRank = Math.max(rankI, rankJ);
                            if (maxRank <= 1) { // Top 2 check
                                potentialPairs.push({u: i, v: partner, score: maxRank});
                            }
                        }
                    }
                });
            }

            potentialPairs.sort((a, b) => a.score - b.score);

            potentialPairs.forEach(p => {
                let u = p.u; 
                let v = p.v;
                if (!fixedRoles.hasOwnProperty(u) && !fixedRoles.hasOwnProperty(v)) {
                    // Tie-break with Borda
                    if (globalBorda[u] >= globalBorda[v]) {
                        fixedRoles[u] = 'L'; fixedRoles[v] = 'F';
                    } else {
                        fixedRoles[u] = 'F'; fixedRoles[v] = 'L';
                    }
                    log.push(`> Fixed Strict Pair (${u}, ${v}) -> ${u}:${fixedRoles[u]}, ${v}:${fixedRoles[v]}`);
                }
            });

            // Step 3: Fill Remaining
            let remaining = [];
            for (let i = 1; i <= n; i++) {
                if (!fixedRoles.hasOwnProperty(i)) remaining.push(i);
            }
            remaining.sort((a, b) => globalBorda[b] - globalBorda[a]); // Descending

            let currentLCount = Object.values(fixedRoles).filter(r => r === 'L').length;
            let targetL = Math.floor(n / 2);
            let neededL = targetL - currentLCount;

            let leaders = [];
            let followers = [];

            // Add fixed agents first
            for (let k in fixedRoles) {
                if (fixedRoles[k] === 'L') leaders.push(parseInt(k));
                else followers.push(parseInt(k));
            }

            // Distribute remaining
            remaining.forEach((agent, idx) => {
                if (idx < neededL) leaders.push(agent);
                else followers.push(agent);
            });

            leaders.sort((a,b)=>a-b);
            followers.sort((a,b)=>a-b);
            
            let LSet = new Set(leaders);
            let FSet = new Set(followers);

            log.push(`> Final Partition -> Leaders: [${leaders.join(', ')}], Followers: [${followers.join(', ')}]`);

            // Step 4: DA
            let prefL = {};
            let prefF = {};

            leaders.forEach(i => {
                prefL[i] = (prefs[i] || []).filter(x => FSet.has(x));
            });
            followers.forEach(i => {
                prefF[i] = (prefs[i] || []).filter(x => LSet.has(x));
            });

            let match = deferredAcceptance(leaders, followers, prefL, prefF);

            return { match, LSet, FSet, g, log };
        }

        // --- 5. UI Handler ---
        function runMechanism() {
            const nInput = document.getElementById('numAgents').value;
            const prefInput = document.getElementById('preferences').value.trim();
            const roleInput = document.getElementById('roles').value.trim();
            const outputDiv = document.getElementById('output');

            if (!nInput || !prefInput) {
                outputDiv.textContent = "Please enter number of agents and preferences.";
                return;
            }

            const n = parseInt(nInput);
            
            // Parse Preferences
            let prefs = {};
            let lines = prefInput.split('\n');
            for (let i = 0; i < n; i++) {
                if (i < lines.length) {
                    let parts = lines[i].trim().split(/\s+/).map(Number);
                    // Filter valid agents 1..n
                    prefs[i+1] = parts.filter(x => x >= 1 && x <= n && x !== (i+1));
                } else {
                    prefs[i+1] = [];
                }
            }

            // Parse Roles
            let rolePref = {};
            let roleParts = roleInput.split(/[\s,]+/); // Split by space or comma
            for (let i = 0; i < n; i++) {
                let r = 'L';
                if (i < roleParts.length) {
                    let val = roleParts[i].toUpperCase();
                    if (val === 'F') r = 'F';
                }
                rolePref[i+1] = r;
            }

            // Run
            let result = runLogic(n, prefs, rolePref);

            // Display
            let displayText = result.log.join('\n') + "\n\n";
            displayText += "==============================\n";
            displayText += "FINAL MATCHING\n";
            displayText += "==============================\n";

            let printed = new Set();
            for (let i = 1; i <= n; i++) {
                if (printed.has(i)) continue;
                
                let partner = result.match.hasOwnProperty(i) ? result.match[i] : null;
                let roleI = result.LSet.has(i) ? "Leader" : "Follower";

                if (partner === null || partner === undefined) {
                    displayText += `Agent ${i} (${roleI}) is Unmatched\n`;
                } else {
                    let roleP = result.LSet.has(partner) ? "Leader" : "Follower";
                    displayText += `Agent ${i} (${roleI}) <--> Agent ${partner} (${roleP})\n`;
                    printed.add(i);
                    printed.add(partner);
                }
            }

            displayText += "------------------------------\n";
            let stability = checkStability(result.match, result.LSet, result.FSet, rolePref, result.g);
            
            if (stability.isStable) {
                displayText += "Verification: The matching is GLOBALLY STABLE.";
            } else {
                displayText += "Verification: The matching is UNSTABLE.\n";
                displayText += `Found ${stability.blockingPairs.length} blocking pair(s): [${stability.blockingPairs.join(', ')}]`;
            }

            outputDiv.textContent = displayText;
        }
    </script>
</body>
</html>